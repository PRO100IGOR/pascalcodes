<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>CnDebug Help</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" href="../css/style.css" type="text/css">
</head>

<body>
<table width="100%" border="0" cellpadding="4">
  <tr>
    <td class="head" height="16">CnDebug Help</td>
  </tr>
  <tr>
    <td bgcolor="#FF9900" height="6"></td>
  </tr>
  <tr>
    <td height=6></td>
  </tr>
</table>
<p class="text">Welcome to use the log debugging tool "CnDebug/CnDebugViewer", which is developed by CnPack team. CnDebug is an interface unit running in Windows / x86 platform, provided to user to output the debug information. Now it only support Object Pascal (CnDebug.pas), can be used in Delphi and C++Builder.</p>
<p class="text">&nbsp;</p>
<p class="title" align="left">Where to use CnDebug?</p>
<p class="text">"Log message" debugging is widely used in our development, especially when breakpoint and step tracing are not applicable. Using MessageBox API to show some variable's value is a common way in "Log message" debugging. But such MessageBox showing is limited and will bring some side effects when the code is related to some re-painting message or complex user interface. We prefer a better way: logging debug message information in background and use other tools to show and analyze them.</p>
<p class="text">Win32 platform provides an API OutputDebugString to log debugging message. If this API was called, the message string will be copied to an internal buffer of Windows. If the program was running under IDE, the message will be captured by Event Log window. If running alone and a Viewer exists, e.g. DebugView, the message will be captured by the Viewer. Otherwise, disappeared.</p>
<p class="text">OutputDebugString is simple, but a little discommodious. One message only contains one string, which is not proper for viewer to distinguish the level or types, and can not be filtered. Comparing to OutputDebugString, CnDebug brings some enhancement to this mechanism, and implements a more powerful interface unit of debug message output for Delphi and C++Builder.</p>

<p class="text">&nbsp;</p>
<p class="title" align="left">CnDebugger Introduction</p>

<p class="text" align="left">CnDebug.pas has a global instance CnDebugger to control and send the debug message. CnDebugger provides a lot of methods to send not only simple string message, but also integer, float, color, RTTI information of objects and components. It can also install an exception handler to log the stack and other contents when exception occurred.</p>
<p class="text" align="left">CnDebugger is created in initialization part of CnDebug.pas, and freed in finalization.</p>
<p class="text">&nbsp;</p>
<p class="title" align="left">A Message from CnDebugger</p>

<p class="text" align="left">For our viewer needs enough information to classify, filter the messages. So there must be more contents than a simple string in each message. A message contains below:</p>
<blockquote><ul>
<li>
<p class="text"><b>Msg</b>: The text message, length limited.
<li>
</li>    
<p class="text"><b>Level</b>: An integer value for distinguish the message level. For example, if we set level = 2 in our filter. The messages whose level &lt;= 2 can be recorded, those &gt; 2 will be discarded.  Now the level range is 0 to 3, Default filter is 3, which means record all. So Level can be used to control the message details.
<li>
</li>
<p class="text"><b>MsgType</b>: Type of this message, e.g. Error or Warning.
<li>
</li>
<p class="text"><b>Tag</b>: An additional tag for each message with limited length (Now is 8). Default is empty. It can be used for single filtering.
</li>
</ul>
</blockquote>
<p class="text" align="left">Above can all be controlled by user through various methods provided by CnDebugger.</p>
<p class="text" align="left">Furthermore, some additional information is generated by CnDebugger internally. They can not be modified by user directly. </p>
<blockquote><ul>
  <li>
<p class="text"><b>Indent</b>: An integer value for viewer to collapse/expand messages in treeview. It's used in Enter or Leave methods of CnDebugger. Note: this information has relation ship with current thread.
<p class="text">
  <li><b>Process ID</b>: Current Process ID.</li>
<p class="text"><li><b>Thread ID</b>: Current Thread ID.</li>
</ul>
</blockquote>
<p class="text" align="left">Users can ignore them when calling sending methods.</p>
<p class="text">&nbsp;</p>
<p class="title" align="left">How CnDebugger Compiled?</p>

<p class="text" align="left">CnDebugger provides two kinds of output methods, Log and Trace. Both of them has similar parameters and function. The difference is: Log methods are only compiled when DEBUG defined when compiling, while Trace methods are compiled for all time, except NDEBUG defined. Here NDEBUG will overwrite DEBUG.</p>
<p class="text" align="left">The expression of compiled is: </p>
<ul><blockquote>
  <li>
Log Compiled := IF<font color="#ff0000">N</font>DEF NDEBUG and IFDEF DEBUG
  </li>
  <li>
Trace Compiled := IF<font color="#ff0000">N</font>DEF NDEBUG
  </li>
  </blockquote>
</ul>

<p class="text" align="left">Log methods, which are only compiled when DEBUG defined, can be used to log some detailed messages in debugging. And Trace methods are compiled in normal situation. They can be used to log some key messages, even in public version of software. Also, you can build an NDEBUG version to disable both kinds of methods.</p>
<p class="text" align="left">DEBUG or other conditions can be defined in Project Options dialog.</p>

<p class="text">&nbsp;</p>
<p class="title" align="left">CnDebugger Exception Handler</p>

<p class="text">CnDebugger can install an Exception handler for the application. When unhandled exception occurred, CnDebugger can record the stack information and the error line number (The application needs to be compiled with debug information). Here CnDebugger uses JCL library to capture the exception. To enable this function, you need to install JCL library and define USE_JCL condition. If no JCL library installed, you need to copy the files listed in the header of CnDebug.pas from JCL source package to your application to compile. "Include TD32 debug Info" or generating Map file option should be opened in compiling to obtain more information when exception raises.

<p class="text">&nbsp;</p>
<p class="title" align="left">CnDebugger Timing</p>
<p class="text">CnDebugger provides StartTimeMark and StopTimeMark method for time measurement. It used x86 asm instructions to obtain the CPU period counter. You can write as below:
</p>
<pre class="text">
   // Start a new time counter, 1 means the counter id.
   StartTimeMark(1);  
   // Do some other things
 
   // Stop the time counter.
   StopTimeMark(1);
</pre>
<p class="text">At StopTimeMark called, CnDebugger will calculate the CPU period counters and send the result to viewer as a message. You can start more than one instance of timing counter, using different counter id.
<p class="text">&nbsp;</p>
<p class="title" align="left">CnDebugger's Performance</p>
<p class="text">CnDebug can use different Channel to send the message out. Currently CnDebug uses share memory map queue as the channel. The share memory map queue should be created and maintained by CnDebugViewer. CnDebug's memory map channel will ignored all messages when no corresponding memory map was created. So if CnDebugViewer not started yet, CnDebug's output methods calling brings little performance effects to the host program.</p>
<p class="text">If CnDebugViewer started and share memory map queue was created. All messages from CnDebug will be copied to this queue, and read out by CnDebugViewer. This memory coping way is better than SendMessage & WM_COPYDATA of uDbg/Overseer in performance aspect. Now CnWizards, the main product of CnPack Team, has already used CnDebug as its debug message output unit. It only brings a little effect to CnWizards' performance. </p>
<p class="text">&nbsp;</p>
<p class="title" align="left">CnDebugger F.A.Q.</p>
<p class="text">Method CnDebugger.EvaluateObject can show an Object's RTTI information in an Inspector-style form in runtime. This function needs condition SUPPORT_EVALUATE.</p>
<p class="text">If your IDE does not support multi-byte character sets (MBCS), CnDebug.pas perhaps can not be compiled for its chinese characters in comments. This time you can use the "Comments Cropper" in CnWizards to delete the comments or only delete the extended ASCII characters and compile it again.</p>
<p class="text">&nbsp;</p><p class="text" align="left">Any questions or suggestions, please contact us: <a href="mailto:master@cnpack.org?subject=About CnPack">master@cnpack.org</a>. We'll try our best to help you.<p class="text" align="left">&nbsp;<p class="title" align="left">Links<p class="text" align="left">
<a href="cndebugviewer.htm">CnDebugViewer Help</a><p class="text" align="left">
<a href="../licenses/license.htm">CnPack IDE Wizards License</a><p class="text" align="left">
<a href="../cnpack/about.htm">About CnPack</a><p class="text" align="left">&nbsp;<hr>
<p class="text" align="center"><a href="http://www.cnpack.org">Copyrights 2001-2011 CnPack Team</a></p>
</body>
</html>